/* @flow */
import test from 'ava'
import createCacher from '../src/index'
import redisCache, { client } from './helpers/redisCacheObject'

const wait = ms => new Promise(resolve => setTimeout(resolve, ms))

const myStrategies = [
  {
    pattern: '/items/:id',
    createCacheKey (params: { id: string }) {
      return 'redis-cache:' + params.id
    },
    expire: 60 * 60 * 1000
  },
  {
    pattern: '/nocache',
    createCacheKey () {
      return 'redis-cache:nocache'
    },
    expire: 1 * 1000
  }
]

type Input = {
  url: string
}

type Result = {
  url: string,
  createdAt: number
}

const func: Input => Promise<Result> = async (input: Input) => {
  return {
    url: input.url,
    createdAt: Date.now()
  }
}

const cacher: Input => Promise<Result> = createCacher(myStrategies, func, redisCache)

const flushAll = () => new Promise((resolve, reject) => {
  client.flushdb((err, _succeeded) => {
    if (err) {
      reject(err)
      return
    }
    resolve()
  })
})

test.beforeEach(async t => {
  await flushAll()
  t.pass()
})

test('returns object if url is cached by createCacheKey', async t => {
  const ret1 = await cacher({url: '/items/aaa'})
  t.deepEqual(ret1, {
    url: '/items/aaa',
    createdAt: ret1.createdAt // generated by inner call
  })

  // return same createdAt with ret1
  const ret2 = await cacher({url: '/items/aaa'})
  t.deepEqual(ret2, {
    url: '/items/aaa',
    createdAt: ret1.createdAt
  })
})

test('always call when url is not cacheable', async t => {
  const ret1 = await cacher({url: '/xxx/yyy'})
  t.deepEqual(ret1, {
    url: '/xxx/yyy',
    createdAt: ret1.createdAt
  })

  // should not use cache
  const ret2 = await cacher({url: '/xxx/yyy'})
  t.deepEqual(ret2, {
    url: '/xxx/yyy',
    createdAt: ret2.createdAt
  })
})

// TODO: This test does not work because redis does not flush in short span.
test('does not return cache with /nocache', async t => {
  const ret1 = await cacher({url: '/nocache'})
  await wait(1200)
  const ret2 = await cacher({url: '/nocache'})

  t.is(ret1.createdAt !== ret2.createdAt)
})
